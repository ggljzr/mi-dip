\chapter{Implementace}
\label{sec:im}

V~této kapitole je popsána implementace nadřazeného systému podle návrhu z~kapitoly \ref{sec:de}. Jednotlivé sekce tedy popisují implementační detaily dílčích částí návrhového vzoru MVC. Poslední sekce \ref{sec:im_auth} se zabývá implementací autentizace uživatele.

\section{Struktura aplikace}

Aplikace nadřazeného systému je rozdělena do tří modulů:

\begin{itemize}
    \item \texttt{mod\_main} -- hlavní modul aplikace. V~tomto modulu je implementován \textit{model} systému popsaný v~sekci \ref{sec:de_model}. \textit{Model} je využíván i ostatními moduly (konkrétně modulem \texttt{mod\_api}). Dále tento modul implementuje webové rozhraní správy nadřazeného systému.
    \item \texttt{mod\_api} -- modul implementující API systému. Zde je implementován \textit{controller} ze sekce \ref{sec:de_api}, definující URL, pomocí kterých mohou podřízené systémy komunikovat s~nadřazeným systémem.
    \item \texttt{mod\_auth} -- modul implementující autentizaci uživatele při přihlašování do webového rozhraní.
\end{itemize}

K~rozdělení aplikace na jednotlivé moduly je použit nástroj frameworku Flask nazvaný \textit{blueprints} \cite{flask_blueprints}.  Hlavní důvod k~využití modulů je oddělení částí aplikace podle jejich funkce.

Při strukturování aplikace jsem vycházel z~článku \textit{How To Structure Large Flask Applications} \cite{flask_large}.

\section{Implementace \textit{modelu}}

Jak je zmíněno v~sekci \ref{sec:de_model}, \textit{model} aplikace je tvořen třídami \texttt{Garage} a \texttt{Event}. Tyto třídy přímo využívají databázi nadřazeného systému, k~jejich implementaci je proto použit framework SQLAlchemy \cite{sqlalchemy}, který výrazně usnadní práci s~databází.

Tento framework poskytuje přístup k~SQL databázím přímo z~jazyka Python, takže není nutné psát prakticky žádný SQL kód. Tabulku v~databázi je možné definovat jako Python třídu s~přísušnými atributy a SQLAlchemy vytvoří odpovídající databázové schéma. 

SQLAlchemy také umožňuje snadno definovat databázové vztahy. V~\textit{modelu} nadřazeného systému se vyskytuje pouze vztah $1:N$ mezi třídami \texttt{Garage} a \texttt{Event} (jedna garáž má mnoho událostí, každá událost má právě jednu garáž). Tento vztah je možno pomocí SQLAlchemy definovat následujícím způsobem:

\begin{listing}[htbp]
\caption{\label{lst:db_relationship} Vytvoření vztahu $1:N$ mezi třídami \texttt{Garage} a \texttt{Event}}
\begin{minted}[bgcolor=codebg]{python}
from sqlalchemy import Column, ForeignKey, Integer
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

# třídy Event a Garage
# dedi SQLAlchemy metody
# třídy Base
class Event(Base):
    ...
    # odkaz na příslušnou garáž
    garage_id = Column(Integer, ForeignKey(
        'Garage.id'), nullable=False)

class Garage(Base): 
    ...
    # definice 1:N vztahu mezi garáží a událostí
    events = relationship('Event', backref='Garage')
\end{minted}
\end{listing}

\subsection{Kontrola zmeškaných hlášení}

V~databázi nadřazeného systému je potřeba pravidelně provádět kontrolu, zda podřízené systémy zaslaly v~očekávaný čas kontrolní hlášení. Pokud bylo plánované hlášení promeškáno, je nutné změnit stav příslušné garáže na \uv{Nehlásí se}.

Aplikace nadřazeného systému nemá v~zásadě možnost, jak tuto kontrolu sama iniciovat, neboť pouze reaguje na příchozí požadavky (od uživatele či podřízeného systému). Provedení kontroly může být důsledkem takového požadavku, například pokud uživatel otevře hlavní stránku webového rozhraní. 

Provádět kontrolu hlášení pouze v~reakci na vnější podnět však není dostatečné. Pokud by nadřazený systém musel pro provedení kontroly hlášení čekat interakci s~webovým rozhraním (nebo například s~podřízeným systémem), nemuselo by vůbec dojít ke změně stavu garáže a tedy ani k~odeslání notifikačního e-mailu. Je tedy nutné zajistit pravidelné provádění kontrol na základě vnitřního podnětu.

Tento problém jsem vyřešil použítím plánovače APScheduler \cite{apscheduler}. APScheduler funguje jako knihovna do Pythonu, a umožňuje plánovat provádění zvolených funkcí. Nejde tedy o~externí program, plánovač je přímo součástí kódu nadřazeného systému \cite{apscheduler}. Vytvoření pravidelné kontroly hlášení podřízených systémů lze implementovat tímto způsobem:

\begin{listing}[htbp]
\caption{\label{lst:scheduler_check} Pravidelná kontrola hlášení podřízených systémů každých 5 minut pomocí knihovny APScheduler}
\begin{minted}[bgcolor=codebg]{python}

from apscheduler.schedulers.background import \
    BackgroundScheduler

# BackgroundScheduler běží v~samostatném vlákně,
# neblokuje tedy webovou aplikaci
scheduler = BackgroundScheduler()

# přidání pravidelného úkolu do plánovače
# Garage.check_reports je statická metoda
# třídy Garage, která provede kontrolu hlášení
# u~všech garáží v~databázi (a případně upraví jejich stav)
scheduler.add_job(Garage.check_reports, 'interval', minutes=5)
scheduler.start()
\end{minted}
\end{listing}

Plánovač se kromě kontroly hlášení hodí také při vypínání registračního módu. Ten z~bezpečnostních důvodů po aktivaci běží po dobu tří minut. Jeho vypnutí je naplánováno obdobně jako kontrola hlášení, jediný rozdíl je, že úkol není spouštěn v~pravidelném intervalu, ale pouze jednou.

\subsection{Zasíláním upozornění}

%posilani mailu pomoci toho eventu zmeny v sqlalchemy

%posilani mailu obecne jak je implementovany

\section{Implementace \textit{view}}

%jinja, makra

%wtforms

%jquery na filtry

\section{Implementace \textit{controlleru}}

%csrf, viz  napsat ze pro add garage a revoke key misto normalni routy, getu a linku pouzivame formulare a post kvuli vochrane pred csrf, viz \url{https://stackoverflow.com/questions/6812765/how-to-demonstrate-a-csrf-attack}. Timhle utokem by nekdo moh vytvaret garaze a rusit api klice, coz neni naka velka skoda ale spis na votravovani no (u~vostatnich veci (tj hlavne change password) to bylo uz driv v~pohode protoze byly pouzity ty flaskforms)

\subsection{API \textit{controller}}

%vyjimka z csrf (neni potreba login, prokazuje se klicem)

\section{Autentizace uživatele}
\label{sec:im_auth}

%asi hlavne bcrypt popsat

%login_required decorator \url{http://flask.pocoo.org/docs/0.12/patterns/viewdecorators/}

%session

%mozna csrf tady, napsat jak je tam zapnuty, ze default je soucasti toho flask_formu ale my ho chceme pro vsechny ty post routy a pak vyjimku pro api modul -- tady napsat jak se nam siknou ty blueprinty

%v~testovani je mozny tenhle utok demonstrovat a ukazat jak pekne nam to funguje (voproti ty prvni verzi kde byl na add garage normalne get). Ted se pri tim pokusu vo utok normalne zvobrazi invalid csrf token nebo tak neco. Pro porovnani zmen puvodni a vopraveny verze viz commit e52a54b2caa8eead85e8df28c738356a7541a1c4 (password redirect, to je posledni verze s~timhle bugem)

\begin{listing}[htbp]
\caption{\label{code:foo} Testovací listing}
\begin{minted}[bgcolor=codebg]{python}
# ... code here ...

import numpy as np

def foo(a):
    print(a)

class FooBar:
    def __init__(self):
        self.b = 10

a = [1, 2, 3, 4]
for i in a:
    if i == 2:
        print("hello world")
\end{minted}
\end{listing}