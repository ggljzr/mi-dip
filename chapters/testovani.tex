\chapter{Testování}
\label{sec:te}

\section{Automatizované testy}

K~aplikaci jsem vytvořil sadu automatizovaných testů, které ověřují funkčnost jednotlivých komponent. Konkrétně jde o~testy pro \textit{model} aplikace (zde je testována především třída \texttt{Garage}), webové rozhraní a API systému. Tyto testy byly implementovány pomocí frameworku pytest \cite{pytest}.

Části aplikace, u~kterých je automatizované testování problematikcé, jako například funkce využívající APScheduler (viz sekce \ref{sec:im_scheduler}) nebo zasílání e-mailů, jsem otestoval ručně.

\subsection{Testovací konfigurace}

Před spuštěním automatizovaných testů je nutné upravit konfiguraci aplikace. Především je třeba určit umístění testovací databáze a souboru s~uživatelským nastavením. Tyto soubory jsou v~průběhu testů upravovány a po dokončení smazány.

Také je nutné vypnout ochranu proti CSRF v~celé aplikaci, což výrazně zjednodušší testování formulářů aplikace. Jelikož požadavky s~metodou \texttt{post} vytvořené v~testech nepocházejí z~webových stránek aplikace, nemohou dodat CSRF \textit{token}, který je součástí formuláře. 

Sdílení \textit{tokenu} mezi aplikací a testy by sice bylo možné implementovat, bylo by však zbytečně komplikované. Za vhodnější postup považuji vypnutí CSRF ocharny pro většinu testů a funkčnost ochrany otestovat v~samostatném testu (viz sekci \ref{sec:te_csrf}).

Změna konfigurace aplikace je provadena nastavením proměnné prostředí \texttt{GARAGE\_SYSTEM\_CONFIG} na soubor se testovací konfigurací (blíže viz sekci \ref{sec:im_config}).

\subsection{Testování \textit{modelu}}

Testování \textit{modelu} aplikace spočívalo především v~testování metod třídy \texttt{Garage}. Třída \texttt{Event} slouží pouze k~uchování dat o~události a neimplementuje žádné metody, které by bylo možné testovat.

Testovány byly následující scénáře:

\begin{itemize}
    \item Přidání garáže.
    \item Smazání garáže.
    \item Kontrola zmeškaných hlášení.
    \item Zaslání kontrolího hlášení.
    \item Změna stavu po zaslání události.
    \item Zneplatnění API klíče.
\end{itemize}

Zde stojí za zmínku test kontroly zmeškaných hlášení. V~něm je garáži zasláno kontrolní hlášení, čímž je určen čas dalšího očekávaného hlášení. Po překročení tohoto času je potřeba otestovat, zda byl stav garáže změnen na \uv{Nehlásí se}.

Jelikož je minimální perioda hlášení 1 minuta, prosté čekání (například pomocí funkce \texttt{sleep()}) by proces testování neúnosně zpomalilo (pro srovnání spuštění všech testů aplikace na běžném počítači zabere asi 4 sekundy). Vhodnější je tedy časový posun nasimulovat.

K~tomu jsem použil knihovnu FreezeGun \cite{freezegun}. Tato knihovna umožňuje explicitně nastavit datum a čas, které vrátí funkce \texttt{now()}, používaná v~implementaci třídy \texttt{Garage}. Použití knihovny při testování kontroly promeškaných hlášení je demonstrováno v~ukázce \ref{lst:freezegun}.

\begin{listing}[htbp]
\caption{\label{lst:freezegun} Test kontroly promeškaných hlášení. Pomocí knihovny FreezeGun je čas nastaven na půlnoc 1. 1. 2011. Poté je čas posunut o~dvě hodiny a otestována změna stavu garáže}
\begin{minted}[bgcolor=codebg]{python}
from freezegun import freeze_time

# všechna volání datetime.datetime.now()
# pocházející z~této funkce vrátí
# hodnotu 2011-01-01 00:00:00
@freeze_time("2011-01-01 00:00:00")
def test_check_report(garage):
    new_garage = garage.add_garage()
    new_garage.period = 60 # explicitní nastavení periody
    new_garage.add_report_event()
    new_garage.check_report()

    assert new_garage.state == garage.STATE_OK

    # nastavení návratové hodnoty funkce now()
    # v~rámci bloku with
    with freeze_time("2011-01-01 02:00:00"):
        new_garage.check_report()
        assert new_garage.state == garage.STATE_NOT_RESPONDING
\end{minted}
\end{listing}

\subsection{Testování API}

\subsection{Testování webového rozhraní}

\subsection{Testování autentizace uživatele}

\subsection{Testování ochrany proti CSRF}
\label{sec:te_csrf}

% test je udelanej v test_auth

\section{Test HTTPS konfigurace}

% lol nasadime to na aws nebo digital ocean, registrujem domenu, dame lets encrypt cert a zkusime sslabs test

% v tyhle kapitole taky poresit to ze se jako bottleneck ty komunikace zda bejt ten https handshake a ze by se to asi dalo vyresti pouzitim sessions na strane klienta http://docs.python-requests.org/en/latest/user/advanced/#session-objects